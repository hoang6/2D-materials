#include "../AMod/AMod.h"
#include "../Util/util.h"
#include <string>
#include <iostream>
#include <sstream>
#include <fstream>
#include <vector>
#include <cmath>
using namespace std;

int sourceEigGPHDynMat(ifstream& _fin, vector<double>& _eigV);

void computeGPHFreeEnergy(const AMod::Molecule& _mol,
			  const vector<double>& _eigV, 
			  const vector<double>& _kTV,
			  vector<double>& _feV);

int main(int argc, char* argv[]) {
  if(argc != 6) {
    cout << "Usage: getGPHFreeEnergy <file_mol> <file_dynMat> <T0> <dT> <nT>" << endl;
    cout << "Note: file_dynMat should be generated by getGPHDynMat with `mesh' on and `verbose' off" << endl;
    return 1;
  }

  /********** READ ARGUMENTS **********/
  AMod::Molecules mols;
  ifstream mfin, fin;
  istringstream iss;
  double T0, dT;
  int nT;
  vector<double> kTV;

  AMod::MolO::setFormat(cout, 14);
  mfin.open(argv[1]);
  if(!mfin.good()) {
    cout << "Error: cannot open file: " << argv[1] << endl;
    return 2;
  }
  mfin >> mols;
  if(mfin.fail() || mols.size() == 0) {
    cout << "Error: no molecule is read" << endl;
    return 3;
  }
  mfin.close();
  fin.open(argv[2]);
  if(!fin.good()) {
    cout << "ERROR: cannot open " << argv[2] << endl;
    return 4;
  }
  iss.str(string(argv[3])+" "+argv[4]+" "+argv[5]);
  iss >> T0 >> dT >> nT;
  if(iss.fail()) {
    cout << "ERROR: illegal arguments" << endl;
    return 5;
  }
  kTV.resize(nT);
  for(int k = 0; k < nT; k++) kTV[k] = (T0+k*dT)*Util::BOLTZMANN_CONSTANT;

  /********** COMPUTE FREE ENERGY **********/
  int count = 0;
  vector<double> eigV;
  vector<double> feV;
  while(sourceEigGPHDynMat(fin, eigV) == 0) {
    if(count >= int(mols.size())) break;
    computeGPHFreeEnergy(mols[count++], eigV, kTV, feV);
    for(int k = 0; k < int(feV.size()); k++) cout << feV[k] << " ";
    cout << endl;
  }//end while(source...

  fin.close();
  return 0;
}

int sourceEigGPHDynMat(ifstream& _fin, vector<double>& _eigV) {
  int sz, k;
  string tline;
  istringstream iss;
  _eigV.clear();
  while(getline(_fin,tline).good()) {
    if(!tline.length()) return 0;
    sz = _eigV.size();
    _eigV.resize(sz+8);
    iss.clear();
    iss.str(tline);
    for(k = 0; k < 8; k++) iss >> _eigV[sz+k];
    if(iss.fail()) return 1;
  }
  return 2;
}

void computeGPHFreeEnergy(const AMod::Molecule& _mol,
			  const vector<double>& _eigV, 
			  const vector<double>& _kTV,
			  vector<double>& _feV) {
  const double hbar = Util::REDUCED_PLANCK_CONSTANT;
  const double carbonMass = 0.012/Util::AVOGADRO_CONSTANT;
  const double eCharge = Util::ELECTRON_CHARGE;
  int ncell = int(_mol.natoms()/2.0);
  int nq2D = int(_eigV.size()/8.0);
  int kmax = int(_eigV.size());
  int cmax = int(_kTV.size());
  int j, k, c;
  double fe[3], kT;
  vector<double> freqV;

  /********** EIG --> FREQUENCY **********/
  freqV.assign(kmax, 0.0);
  for(k = 0; k < kmax; k++) {
    if(k%8 == 0 || k%8 == 1) 
      freqV[k] = _eigV[k];
    else
      freqV[k] = hbar*sqrt(fabs(_eigV[k])*eCharge/1.0e-20/carbonMass);
  }
  
  /********** FREE ENERGY 0 **********/
  fe[0] = _mol.potential()/ncell;

  /********** FREE ENERGY 1 **********/
  fe[1] = 0.0;
  for(k = 0; k < kmax; k += 8) {
    for(j = 2; j < 8; j++) {
      fe[1] += 0.5*freqV[k+j];
    }
  }//end for(k...
  fe[1] *= 1.0/nq2D;

  /********** FREE ENERGY 2 **********/
  _feV.assign(3*_kTV.size(), 0.0);
  for(c = 0; c < cmax; c++) {
    kT = _kTV[c];
    fe[2] = 0.0;
    for(k = 0; k < kmax; k += 8) {
      for(j = 2; j < 8; j++) {
	if(freqV[k+j] == 0.0) continue;
	fe[2] += log(-Util::expm1(-freqV[k+j]/kT));
      }
    }//end for(k...
    fe[2] *= kT/nq2D;
    _feV[3*c  ] = fe[0];
    _feV[3*c+1] = fe[1];
    _feV[3*c+2] = fe[2];
  }//end for(c...
}
